/* eslint-disable @typescript-eslint/no-use-before-define */
/*
 * SPDX-FileCopyrightText: 2024 Zextras <https://www.zextras.com>
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 */
import React, { FunctionComponent, ReactElement, useCallback, useEffect, useState } from 'react';

import { act, screen } from '@testing-library/react';
import * as shell from '@zextras/carbonio-shell-ui';

import { UserEvent, setupTest } from '../../../../../../carbonio-ui-commons/test/test-setup';
import { Participant } from '../../../../../../types';
import { RecipientsRow, ContactType } from '../recipients-row';

describe('recipients-row', () => {
	it('do not change the id attribute on recipient update from ContactInput', async () => {
		mockContactInput({ autogeneratedId: () => 'fakeId' });
		const { user } = setupTest(<TestableRecipientsRow />);

		await paste(user, screen.getByTestId('mockedContactInput'), 'another@ema.il');

		expect(screen.getByTestId('mockedContactValue')).toHaveTextContent(
			'[{"id":"fakeId","email":"another@ema.il","type":"f","address":"another@ema.il","label":"another@ema.il"}]'
		);
	});

	describe('when ContactInput is available', () => {
		beforeEach(() => {
			mockContactInput({ isAvailable: false });
		});

		it('create a chip rendering the entire text when invalid', async () => {
			const { user } = setupTest(<TestableRecipientsRow />);

			await paste(user, screen.getByRole('textbox'), '"not valid" <notvalid>');

			expect(await screen.findByText('"not valid" <notvalid>')).toBeInTheDocument();
		});

		it('create a chip rendering only the email part when valid', async () => {
			const { user } = setupTest(<TestableRecipientsRow />);

			await paste(user, screen.getByRole('textbox'), '"valid" <valid@ema.il>');

			expect(await screen.findByText('valid@ema.il')).toBeInTheDocument();
		});
	});
});

async function paste(user: UserEvent, element: HTMLElement, text: string): Promise<void> {
	await user.click(element);
	await act(async () => {
		await user.paste({ getData: () => text } as unknown as DataTransfer);
	});
}

/*
 * We need to define a Testable RecipientRow because we want to test how the recipient is updated,
 * but the current implementation of the component do not handle the recipient update itself,
 * it just pass the value to the parent component
 */
function TestableRecipientsRow(): React.ReactElement {
	const [recipients, setRecipients] = useState<Participant[]>([]);

	const onChange = useCallback(
		(participants: Participant[]): void => setRecipients(participants),
		[]
	);

	return (
		<RecipientsRow
			type="f"
			label="label"
			recipients={recipients}
			onRecipientsChange={onChange}
		></RecipientsRow>
	);
}

function mockContactInput({
	autogeneratedId = (): string => Date.now().toString(),
	isAvailable = true
}: {
	autogeneratedId?: () => string;
	isAvailable?: boolean;
}): void {
	jest
		.spyOn(shell, 'useIntegratedComponent')
		.mockReturnValue([generateMockedContactInput(autogeneratedId), isAvailable]);
}

/*
 * We need to define a minimal version that updated the ids of the contacts like the original component
 * we avoided to replicate all the logic to avoid inconsistencies
 */
type MockContantInputType = {
	onChange: ((items: ContactType[]) => void) | undefined;
	defaultValue: ContactType[];
};
function generateMockedContactInput(
	autogeneratedId: () => string
): FunctionComponent<Record<string, unknown>> {
	function MockedContactInput({ onChange, defaultValue }: MockContantInputType): ReactElement {
		const [values, setValues] = useState<ContactType[]>([]);

		useEffect(() => onChange?.(values), [values, onChange]);

		const onInputChange: React.ChangeEventHandler<HTMLInputElement> = useCallback(
			(e) => {
				setValues([
					...values,
					{
						id: autogeneratedId(),
						email: e.target.value
					}
				]);
			},
			[values]
		);

		return (
			<>
				<input data-testid="mockedContactInput" onChange={onInputChange} />
				<br />
				<label data-testid="mockedContactValue">{JSON.stringify(defaultValue)}</label>
			</>
		);
	}

	return MockedContactInput as FunctionComponent<Record<string, unknown>>;
}
